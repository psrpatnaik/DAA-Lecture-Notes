<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol.lst-kix_h1jtoqhbt4lr-4.start{counter-reset:lst-ctn-kix_h1jtoqhbt4lr-4 0}.lst-kix_hfdtpabz0pfx-3>li{counter-increment:lst-ctn-kix_hfdtpabz0pfx-3}ol.lst-kix_hfdtpabz0pfx-8.start{counter-reset:lst-ctn-kix_hfdtpabz0pfx-8 0}.lst-kix_h1jtoqhbt4lr-0>li:before{content:"" counter(lst-ctn-kix_h1jtoqhbt4lr-0,decimal) ". "}.lst-kix_z514lf62usd-3>li:before{content:"\0025cf  "}ol.lst-kix_h1jtoqhbt4lr-8.start{counter-reset:lst-ctn-kix_h1jtoqhbt4lr-8 0}.lst-kix_z514lf62usd-2>li:before{content:"\0025a0  "}ol.lst-kix_h1jtoqhbt4lr-1.start{counter-reset:lst-ctn-kix_h1jtoqhbt4lr-1 0}.lst-kix_z514lf62usd-1>li:before{content:"\0025cb  "}ul.lst-kix_z514lf62usd-2{list-style-type:none}.lst-kix_h1jtoqhbt4lr-2>li:before{content:"" counter(lst-ctn-kix_h1jtoqhbt4lr-2,lower-roman) ". "}ul.lst-kix_z514lf62usd-1{list-style-type:none}.lst-kix_hfdtpabz0pfx-8>li{counter-increment:lst-ctn-kix_hfdtpabz0pfx-8}ul.lst-kix_z514lf62usd-0{list-style-type:none}.lst-kix_hfdtpabz0pfx-2>li{counter-increment:lst-ctn-kix_hfdtpabz0pfx-2}ol.lst-kix_hfdtpabz0pfx-1.start{counter-reset:lst-ctn-kix_hfdtpabz0pfx-1 0}.lst-kix_h1jtoqhbt4lr-1>li:before{content:"" counter(lst-ctn-kix_h1jtoqhbt4lr-1,lower-latin) ". "}.lst-kix_h1jtoqhbt4lr-5>li{counter-increment:lst-ctn-kix_h1jtoqhbt4lr-5}ul.lst-kix_z514lf62usd-6{list-style-type:none}.lst-kix_z514lf62usd-0>li:before{content:"\0025cf  "}ul.lst-kix_z514lf62usd-5{list-style-type:none}ul.lst-kix_z514lf62usd-4{list-style-type:none}ul.lst-kix_z514lf62usd-3{list-style-type:none}ul.lst-kix_z514lf62usd-8{list-style-type:none}ul.lst-kix_z514lf62usd-7{list-style-type:none}ol.lst-kix_hfdtpabz0pfx-4.start{counter-reset:lst-ctn-kix_hfdtpabz0pfx-4 0}.lst-kix_h1jtoqhbt4lr-6>li{counter-increment:lst-ctn-kix_h1jtoqhbt4lr-6}ol.lst-kix_h1jtoqhbt4lr-5.start{counter-reset:lst-ctn-kix_h1jtoqhbt4lr-5 0}ol.lst-kix_hfdtpabz0pfx-7.start{counter-reset:lst-ctn-kix_hfdtpabz0pfx-7 0}.lst-kix_z514lf62usd-4>li:before{content:"\0025cb  "}.lst-kix_hfdtpabz0pfx-1>li{counter-increment:lst-ctn-kix_hfdtpabz0pfx-1}.lst-kix_z514lf62usd-5>li:before{content:"\0025a0  "}ol.lst-kix_hfdtpabz0pfx-0{list-style-type:none}.lst-kix_hfdtpabz0pfx-4>li{counter-increment:lst-ctn-kix_hfdtpabz0pfx-4}ol.lst-kix_hfdtpabz0pfx-0.start{counter-reset:lst-ctn-kix_hfdtpabz0pfx-0 0}ol.lst-kix_hfdtpabz0pfx-1{list-style-type:none}.lst-kix_z514lf62usd-7>li:before{content:"\0025cb  "}ol.lst-kix_hfdtpabz0pfx-2{list-style-type:none}.lst-kix_hfdtpabz0pfx-7>li{counter-increment:lst-ctn-kix_hfdtpabz0pfx-7}ol.lst-kix_hfdtpabz0pfx-3{list-style-type:none}.lst-kix_z514lf62usd-6>li:before{content:"\0025cf  "}ol.lst-kix_hfdtpabz0pfx-4{list-style-type:none}ol.lst-kix_hfdtpabz0pfx-5{list-style-type:none}.lst-kix_h1jtoqhbt4lr-3>li{counter-increment:lst-ctn-kix_h1jtoqhbt4lr-3}ol.lst-kix_hfdtpabz0pfx-6{list-style-type:none}ol.lst-kix_hfdtpabz0pfx-7{list-style-type:none}ol.lst-kix_hfdtpabz0pfx-8{list-style-type:none}.lst-kix_h1jtoqhbt4lr-0>li{counter-increment:lst-ctn-kix_h1jtoqhbt4lr-0}ol.lst-kix_h1jtoqhbt4lr-2.start{counter-reset:lst-ctn-kix_h1jtoqhbt4lr-2 0}.lst-kix_z514lf62usd-8>li:before{content:"\0025a0  "}ol.lst-kix_hfdtpabz0pfx-3.start{counter-reset:lst-ctn-kix_hfdtpabz0pfx-3 0}.lst-kix_hfdtpabz0pfx-6>li{counter-increment:lst-ctn-kix_hfdtpabz0pfx-6}.lst-kix_hfdtpabz0pfx-0>li:before{content:"" counter(lst-ctn-kix_hfdtpabz0pfx-0,decimal) ". "}.lst-kix_hfdtpabz0pfx-1>li:before{content:"" counter(lst-ctn-kix_hfdtpabz0pfx-1,lower-latin) ". "}.lst-kix_h1jtoqhbt4lr-2>li{counter-increment:lst-ctn-kix_h1jtoqhbt4lr-2}.lst-kix_hfdtpabz0pfx-7>li:before{content:"" counter(lst-ctn-kix_hfdtpabz0pfx-7,lower-latin) ". "}.lst-kix_hfdtpabz0pfx-8>li:before{content:"" counter(lst-ctn-kix_hfdtpabz0pfx-8,lower-roman) ". "}ol.lst-kix_hfdtpabz0pfx-6.start{counter-reset:lst-ctn-kix_hfdtpabz0pfx-6 0}.lst-kix_hfdtpabz0pfx-5>li{counter-increment:lst-ctn-kix_hfdtpabz0pfx-5}ol.lst-kix_h1jtoqhbt4lr-6.start{counter-reset:lst-ctn-kix_h1jtoqhbt4lr-6 0}.lst-kix_h1jtoqhbt4lr-8>li{counter-increment:lst-ctn-kix_h1jtoqhbt4lr-8}.lst-kix_h1jtoqhbt4lr-6>li:before{content:"" counter(lst-ctn-kix_h1jtoqhbt4lr-6,decimal) ". "}.lst-kix_h1jtoqhbt4lr-7>li:before{content:"" counter(lst-ctn-kix_h1jtoqhbt4lr-7,lower-latin) ". "}ol.lst-kix_h1jtoqhbt4lr-3.start{counter-reset:lst-ctn-kix_h1jtoqhbt4lr-3 0}ol.lst-kix_h1jtoqhbt4lr-1{list-style-type:none}ol.lst-kix_h1jtoqhbt4lr-0{list-style-type:none}.lst-kix_h1jtoqhbt4lr-3>li:before{content:"" counter(lst-ctn-kix_h1jtoqhbt4lr-3,decimal) ". "}ol.lst-kix_hfdtpabz0pfx-2.start{counter-reset:lst-ctn-kix_hfdtpabz0pfx-2 0}.lst-kix_h1jtoqhbt4lr-1>li{counter-increment:lst-ctn-kix_h1jtoqhbt4lr-1}.lst-kix_h1jtoqhbt4lr-4>li:before{content:"" counter(lst-ctn-kix_h1jtoqhbt4lr-4,lower-latin) ". "}.lst-kix_h1jtoqhbt4lr-5>li:before{content:"" counter(lst-ctn-kix_h1jtoqhbt4lr-5,lower-roman) ". "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_h1jtoqhbt4lr-4>li{counter-increment:lst-ctn-kix_h1jtoqhbt4lr-4}ol.lst-kix_h1jtoqhbt4lr-0.start{counter-reset:lst-ctn-kix_h1jtoqhbt4lr-0 0}ol.lst-kix_h1jtoqhbt4lr-7.start{counter-reset:lst-ctn-kix_h1jtoqhbt4lr-7 0}.lst-kix_h1jtoqhbt4lr-7>li{counter-increment:lst-ctn-kix_h1jtoqhbt4lr-7}ol.lst-kix_h1jtoqhbt4lr-8{list-style-type:none}.lst-kix_hfdtpabz0pfx-6>li:before{content:"" counter(lst-ctn-kix_hfdtpabz0pfx-6,decimal) ". "}ol.lst-kix_h1jtoqhbt4lr-7{list-style-type:none}ol.lst-kix_h1jtoqhbt4lr-6{list-style-type:none}ol.lst-kix_h1jtoqhbt4lr-5{list-style-type:none}ol.lst-kix_h1jtoqhbt4lr-4{list-style-type:none}.lst-kix_hfdtpabz0pfx-4>li:before{content:"" counter(lst-ctn-kix_hfdtpabz0pfx-4,lower-latin) ". "}.lst-kix_hfdtpabz0pfx-5>li:before{content:"" counter(lst-ctn-kix_hfdtpabz0pfx-5,lower-roman) ". "}ol.lst-kix_h1jtoqhbt4lr-3{list-style-type:none}ol.lst-kix_h1jtoqhbt4lr-2{list-style-type:none}.lst-kix_hfdtpabz0pfx-2>li:before{content:"" counter(lst-ctn-kix_hfdtpabz0pfx-2,lower-roman) ". "}.lst-kix_hfdtpabz0pfx-3>li:before{content:"" counter(lst-ctn-kix_hfdtpabz0pfx-3,decimal) ". "}.lst-kix_hfdtpabz0pfx-0>li{counter-increment:lst-ctn-kix_hfdtpabz0pfx-0}.lst-kix_h1jtoqhbt4lr-8>li:before{content:"" counter(lst-ctn-kix_h1jtoqhbt4lr-8,lower-roman) ". "}ol.lst-kix_hfdtpabz0pfx-5.start{counter-reset:lst-ctn-kix_hfdtpabz0pfx-5 0}ol{margin:0;padding:0}table td,table th{padding:0}.c10{-webkit-text-decoration-skip:none;color:#1155cc;font-weight:400;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:11pt;font-family:"Arial";font-style:normal}.c1{background-color:#f7f9fa;color:#263238;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Consolas";font-style:normal}.c13{background-color:#ffffff;padding-top:0pt;padding-bottom:7pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c16{margin-left:36pt;padding-top:3pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c5{background-color:#ffffff;padding-top:0pt;padding-bottom:11pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c14{background-color:#ffffff;padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c7{padding-top:0pt;padding-bottom:10pt;line-height:1.6;orphans:2;widows:2;text-align:left;height:11pt}.c29{background-color:#ffffff;padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c36{padding-top:4pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c8{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c28{padding-top:0pt;padding-bottom:22pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c0{padding-top:10pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c34{padding-top:10pt;padding-bottom:4pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c31{padding-top:0pt;padding-bottom:10pt;line-height:1.6;orphans:2;widows:2;text-align:left}.c26{text-decoration-skip-ink:none;font-size:11pt;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c12{background-color:#f7f9fa;font-size:10pt;font-family:"Consolas";color:#006a00;font-weight:400}.c6{background-color:#f7f9fa;font-size:10pt;font-family:"Consolas";color:#aa0d91;font-weight:400}.c3{background-color:#f7f9fa;font-size:10pt;font-family:"Consolas";color:#263238;font-weight:400}.c21{background-color:#f7f9fa;font-size:10pt;font-family:"Microsoft Yahei";color:#546e7a;font-weight:400}.c20{background-color:#f7f9fa;font-size:10pt;font-family:"Consolas";color:#5c2699;font-weight:400}.c2{background-color:#f7f9fa;font-size:10pt;font-family:"Consolas";color:#1c00cf;font-weight:400}.c23{background-color:#ffffff;color:#616161;font-weight:400;font-size:10.5pt;font-family:"Microsoft Yahei"}.c32{color:#980000;font-weight:400;font-size:10.5pt;font-family:"Microsoft Yahei"}.c4{font-size:10.5pt;font-family:"Microsoft Yahei";color:#424242;font-weight:400}.c22{color:#000000;font-weight:400;font-size:11pt;font-family:"Arial"}.c27{color:#000000;font-weight:400;font-size:23pt;font-family:"Microsoft Yahei"}.c24{color:#000000;font-weight:400;font-size:20pt;font-family:"Arial"}.c19{color:#000000;font-weight:400;font-size:13pt;font-family:"Microsoft Yahei"}.c30{color:#424242;font-weight:400;font-size:12pt;font-family:"Microsoft Yahei"}.c11{font-size:10.5pt;font-family:"Microsoft Yahei";color:#607d8b;font-weight:400}.c15{text-decoration:none;vertical-align:baseline;font-style:normal}.c35{padding:0;margin:0}.c9{color:inherit;text-decoration:inherit}.c37{max-width:468pt;padding:72pt 72pt 72pt 72pt}.c17{margin-left:36pt;padding-left:0pt}.c33{background-color:#ffffff}.c18{height:20pt}.c25{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c33 c37"><h1 class="c29" id="h.l6w1zuafes19"><span class="c27 c15">Compiled from LeetCode</span></h1><h1 class="c29" id="h.besaxjku6dxq"><span class="c27 c15">(P.S.R.Patnaik)</span></h1><h1 class="c14" id="h.j5rvf5z0uf9a"><span class="c15 c27">Index:</span></h1><p class="c36"><span class="c26"><a class="c9" href="#h.l6w1zuafes19">Compiled from LeetCode</a></span></p><p class="c0"><span class="c26"><a class="c9" href="#h.besaxjku6dxq">(P.S.R.Patnaik)</a></span></p><p class="c0"><span class="c26"><a class="c9" href="#h.j5rvf5z0uf9a">Index:</a></span></p><p class="c0"><span class="c26"><a class="c9" href="#h.7p3moqnk2y6f">DP Problem Patterns</a></span></p><p class="c0"><span class="c10"><a class="c9" href="#h.hm0b5vt7px7u">Minimum (Maximum) Path to Reach a Target</a></span></p><p class="c16"><span class="c10"><a class="c9" href="#h.v4vhycol5k29">Statement</a></span></p><p class="c16"><span class="c10"><a class="c9" href="#h.el8q18k6830u">Approach</a></span></p><p class="c16"><span class="c10"><a class="c9" href="#h.vprobsqk5td">Similar Problems</a></span></p><p class="c0"><span class="c10"><a class="c9" href="#h.j19h98pem311">Distinct Ways</a></span></p><p class="c16"><span class="c10"><a class="c9" href="#h.wsrqxyxt9q2v">Statement</a></span></p><p class="c16"><span class="c10"><a class="c9" href="#h.kjqxdreybsgy">Approach</a></span></p><p class="c16"><span class="c10"><a class="c9" href="#h.exvrkw1o08o8">Similar Problems</a></span></p><p class="c0"><span class="c10"><a class="c9" href="#h.xroin455hlhm">Merging Intervals</a></span></p><p class="c16"><span class="c10"><a class="c9" href="#h.a5y2y343bbtw">Statement</a></span></p><p class="c16"><span class="c10"><a class="c9" href="#h.douaiqvunozw">Approach</a></span></p><p class="c16"><span class="c10"><a class="c9" href="#h.5mbjyie3sna8">Similar Problems</a></span></p><p class="c0"><span class="c10"><a class="c9" href="#h.5rzngwk6vmzf">DP on Strings</a></span></p><p class="c16"><span class="c10"><a class="c9" href="#h.od07c3lstaj">Statement</a></span></p><p class="c16"><span class="c10"><a class="c9" href="#h.aj9j1ee8f4ky">Approach</a></span></p><p class="c0"><span class="c10"><a class="c9" href="#h.xcpusp3qpira">Decision Making</a></span></p><p class="c16"><span class="c10"><a class="c9" href="#h.mkndmkhbv0ql">Statement</a></span></p><p class="c16"><span class="c10"><a class="c9" href="#h.qxjylk58cfn1">Approach</a></span></p><p class="c34"><span class="c10"><a class="c9" href="#h.vgkeknkvvefj">From good to great. How to approach most DP problems.</a></span></p><h1 class="c14 c18" id="h.9ixfs4bf1g7"><span class="c27 c15"></span></h1><hr style="page-break-before:always;display:none;"><h1 class="c14 c18" id="h.8qxb1d81z6hv"><span class="c27 c15"></span></h1><h1 class="c14" id="h.7p3moqnk2y6f"><span class="c27 c15">DP Problem Patterns</span></h1><hr><p class="c8 c25"><span class="c22 c15"></span></p><ol class="c35 lst-kix_hfdtpabz0pfx-0 start" start="1"><li class="c5 c17 li-bullet-0"><span class="c15 c32">Minimum (Maximum) Path to Reach a Target</span></li><li class="c5 c17 li-bullet-0"><span class="c32 c15">Distinct Ways</span></li><li class="c5 c17 li-bullet-0"><span class="c32 c15">Merging Intervals</span></li><li class="c5 c17 li-bullet-0"><span class="c32 c15">DP on Strings</span></li><li class="c5 c17 li-bullet-0"><span class="c32">Decision Making</span></li></ol><p class="c25 c34"><span class="c10"></span></p><h1 class="c14" id="h.hm0b5vt7px7u"><span class="c27 c15">Minimum (Maximum) Path to Reach a Target</span></h1><hr><p class="c8 c25"><span class="c22 c15"></span></p><p class="c5"><span class="c4 c15">Generate problem statement for this pattern</span></p><h3 class="c13" id="h.v4vhycol5k29"><span class="c19 c15">Statement</span></h3><p class="c28"><span class="c15 c23">Given a target find minimum (maximum) cost / path / sum to reach the target.</span></p><h3 class="c13" id="h.el8q18k6830u"><span class="c15 c19">Approach</span></h3><p class="c28"><span class="c23 c15">Choose minimum (maximum) path among all possible paths before the current state, then add value for the current state.</span></p><p class="c8"><span class="c3">routes[i] = min(routes[i</span><span class="c2">-1</span><span class="c3">], routes[i</span><span class="c2">-2</span><span class="c1">], ... , routes[i-k]) + cost[i]</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c4 c15">Generate optimal solutions for all values in the target and return the value for the target.</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">1</span><span class="c1">; i &lt;= target; ++i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;j = </span><span class="c2">0</span><span class="c1">; j &lt; ways.size(); ++j) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">if</span><span class="c1">&nbsp;(ways[j] &lt;= i) {</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i] = min(dp[i], dp[i - ways[j]]) + cost / path / sum;</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">}</span></p><p class="c8"><span class="c1">&nbsp;</span></p><p class="c8"><span class="c6">return</span><span class="c1">&nbsp;dp[target]</span></p><p class="c7"><span class="c1"></span></p><h3 class="c13" id="h.vprobsqk5td"><span class="c19 c15">Similar Problems</span></h3><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/min-cost-climbing-stairs/&amp;sa=D&amp;source=editors&amp;ust=1627719362113000&amp;usg=AOvVaw1yefBs6_Nc1OaqB1bzvkUY">746. Min Cost Climbing Stairs</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Easy</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">2</span><span class="c1">; i &lt;= n; ++i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;dp[i] = min(dp[i</span><span class="c2">-1</span><span class="c3">], dp[i</span><span class="c2">-2</span><span class="c3">]) + (i == n ? </span><span class="c2">0</span><span class="c1">&nbsp;: cost[i]);</span></p><p class="c8"><span class="c1">}</span></p><p class="c8"><span class="c1">&nbsp;</span></p><p class="c8"><span class="c6">return</span><span class="c1">&nbsp;dp[n]</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/minimum-path-sum/&amp;sa=D&amp;source=editors&amp;ust=1627719362114000&amp;usg=AOvVaw0X8oQrmbyhWdFTk9TvbxKM">64. Minimum Path Sum</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">1</span><span class="c1">; i &lt; n; ++i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;j = </span><span class="c2">1</span><span class="c1">; j &lt; m; ++j) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;grid[i][j] = min(grid[i</span><span class="c2">-1</span><span class="c3">][j], grid[i][j</span><span class="c2">-1</span><span class="c1">]) + grid[i][j];</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">}</span></p><p class="c8"><span class="c1">&nbsp;</span></p><p class="c8"><span class="c6">return</span><span class="c3">&nbsp;grid[n</span><span class="c2">-1</span><span class="c3">][m</span><span class="c2">-1</span><span class="c1">]</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/coin-change/&amp;sa=D&amp;source=editors&amp;ust=1627719362115000&amp;usg=AOvVaw2VQ9Br425JYMSkOehEbpJR">322. Coin Change</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;j = </span><span class="c2">1</span><span class="c1">; j &lt;= amount; ++j) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">0</span><span class="c1">; i &lt; coins.size(); ++i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">if</span><span class="c1">&nbsp;(coins[i] &lt;= j) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[j] = min(dp[j], dp[j - coins[i]] + </span><span class="c2">1</span><span class="c1">);</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/minimum-falling-path-sum/&amp;sa=D&amp;source=editors&amp;ust=1627719362116000&amp;usg=AOvVaw1tLBNf-wmUKzlpVLEwwSs1">931. Minimum Falling Path Sum</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/minimum-cost-for-tickets/&amp;sa=D&amp;source=editors&amp;ust=1627719362117000&amp;usg=AOvVaw2BO9WKPkN5a_-xwwSbj_ZS">983. Minimum Cost For Tickets</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/2-keys-keyboard/&amp;sa=D&amp;source=editors&amp;ust=1627719362117000&amp;usg=AOvVaw0ms8823baKVmXYNqhO8xWs">650. 2 Keys Keyboard</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/perfect-squares/&amp;sa=D&amp;source=editors&amp;ust=1627719362118000&amp;usg=AOvVaw1rlzHCjHmrlsL7SnVFdgsX">279. Perfect Squares</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/last-stone-weight-ii/&amp;sa=D&amp;source=editors&amp;ust=1627719362118000&amp;usg=AOvVaw3caU1heh8Jwv5xygt0i-4H">1049. Last Stone Weight II</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/triangle/&amp;sa=D&amp;source=editors&amp;ust=1627719362118000&amp;usg=AOvVaw3TyrF6WT0ONp9x0FlsWrlz">120. Triangle</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/ones-and-zeroes/&amp;sa=D&amp;source=editors&amp;ust=1627719362119000&amp;usg=AOvVaw3mBUgiNG4Y5mtXO7z2B6ZW">474. Ones and Zeroes</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/maximal-square/&amp;sa=D&amp;source=editors&amp;ust=1627719362119000&amp;usg=AOvVaw11Z-CJOAPOqZU8mQCaYBNS">221. Maximal Square</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/coin-change/&amp;sa=D&amp;source=editors&amp;ust=1627719362120000&amp;usg=AOvVaw0t4FB9SABuVGZdZTIUSghV">322. Coin Change</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/&amp;sa=D&amp;source=editors&amp;ust=1627719362120000&amp;usg=AOvVaw3Jim1_gDVYCIUDz8Vx757l">1240. Tiling a Rectangle with the Fewest Squares</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Hard</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/dungeon-game/&amp;sa=D&amp;source=editors&amp;ust=1627719362120000&amp;usg=AOvVaw0vpAcIRZ6QAghTw9G8-lrh">174. Dungeon Game</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Hard</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/minimum-number-of-refueling-stops/&amp;sa=D&amp;source=editors&amp;ust=1627719362121000&amp;usg=AOvVaw31CUyN7lxlW89v_HAtwc3k">871. Minimum Number of Refueling Stops</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Hard</span></p><h1 class="c14" id="h.j19h98pem311"><span class="c27 c15">Distinct Ways</span></h1><hr><p class="c8 c25"><span class="c22 c15"></span></p><p class="c5"><span class="c4 c15">Generate problem statement for this pattern</span></p><h3 class="c13" id="h.wsrqxyxt9q2v"><span class="c19 c15">Statement</span></h3><p class="c28"><span class="c23 c15">Given a target find a number of distinct ways to reach the target.</span></p><h3 class="c13" id="h.kjqxdreybsgy"><span class="c19 c15">Approach</span></h3><p class="c28"><span class="c23 c15">Sum all possible ways to reach the current state.</span></p><p class="c8"><span class="c3">routes[i] = routes[i</span><span class="c2">-1</span><span class="c3">] + routes[i</span><span class="c2">-2</span><span class="c1">], ... , + routes[i-k]</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c4 c15">Generate sum for all values in the target and return the value for the target.</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">1</span><span class="c1">; i &lt;= target; ++i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;j = </span><span class="c2">0</span><span class="c1">; j &lt; ways.size(); ++j) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">if</span><span class="c1">&nbsp;(ways[j] &lt;= i) {</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i] += dp[i - ways[j]];</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">}</span></p><p class="c8"><span class="c1">&nbsp;</span></p><p class="c8"><span class="c6">return</span><span class="c1">&nbsp;dp[target]</span></p><p class="c7"><span class="c1"></span></p><h3 class="c13" id="h.exvrkw1o08o8"><span class="c19 c15">Similar Problems</span></h3><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/climbing-stairs/&amp;sa=D&amp;source=editors&amp;ust=1627719362123000&amp;usg=AOvVaw0Ra53HCQBCsqTtdxxcVzIz">70. Climbing Stairs</a></span><span class="c4">&nbsp;</span><span class="c21 c15">easy</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;stair = </span><span class="c2">2</span><span class="c1">; stair &lt;= n; ++stair) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;step = </span><span class="c2">1</span><span class="c3">; step &lt;= </span><span class="c2">2</span><span class="c1">; ++step) {</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;dp[stair] += dp[stair-step]; &nbsp; </span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/unique-paths/&amp;sa=D&amp;source=editors&amp;ust=1627719362124000&amp;usg=AOvVaw26FcTghgDTfQ5VsTzrMe-L">62. Unique Paths</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">1</span><span class="c1">; i &lt; m; ++i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;j = </span><span class="c2">1</span><span class="c1">; j &lt; n; ++j) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = dp[i][j</span><span class="c2">-1</span><span class="c3">] + dp[i</span><span class="c2">-1</span><span class="c1">][j];</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/&amp;sa=D&amp;source=editors&amp;ust=1627719362125000&amp;usg=AOvVaw0UBzVxelCwGvrH4o_O4Nl5">1155. Number of Dice Rolls With Target Sum</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;rep = </span><span class="c2">1</span><span class="c1">; rep &lt;= d; ++rep) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c20">vector</span><span class="c3">&lt;</span><span class="c6">int</span><span class="c3">&gt; new_ways(target+</span><span class="c2">1</span><span class="c1">);</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;already = </span><span class="c2">0</span><span class="c1">; already &lt;= target; ++already) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;pipe = </span><span class="c2">1</span><span class="c1">; pipe &lt;= f; ++pipe) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">if</span><span class="c3">&nbsp;(already - pipe &gt;= </span><span class="c2">0</span><span class="c1">) {</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new_ways[already] += ways[already - pipe];</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new_ways[already] %= mod;</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;ways = new_ways;</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c4 c15">Note</span></p><p class="c5"><span class="c4 c15">Some questions point out the number of repetitions, in that case, add one more loop to simulate every repetition.</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/knight-probability-in-chessboard/&amp;sa=D&amp;source=editors&amp;ust=1627719362127000&amp;usg=AOvVaw0Yr7L5MfwWUbVNx0Nvl_ve">688. Knight Probability in Chessboard</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/target-sum/&amp;sa=D&amp;source=editors&amp;ust=1627719362128000&amp;usg=AOvVaw1VuwqbJ09XHkqT3a2VkQ7O">494. Target Sum</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/combination-sum-iv/&amp;sa=D&amp;source=editors&amp;ust=1627719362128000&amp;usg=AOvVaw0BaoQs8uxRT7XE_eWTpESf">377. Combination Sum IV</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/knight-dialer/&amp;sa=D&amp;source=editors&amp;ust=1627719362128000&amp;usg=AOvVaw26tbif0jD4vvlFKqDIfoQy">935. Knight Dialer</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/dice-roll-simulation/&amp;sa=D&amp;source=editors&amp;ust=1627719362129000&amp;usg=AOvVaw1TvH4sC0AXP3dca8ehvaN8">1223. Dice Roll Simulation</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/partition-equal-subset-sum/&amp;sa=D&amp;source=editors&amp;ust=1627719362129000&amp;usg=AOvVaw0tQG58XMbGocZL8eFFMsOK">416. Partition Equal Subset Sum</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/soup-servings/&amp;sa=D&amp;source=editors&amp;ust=1627719362130000&amp;usg=AOvVaw3yYNrFayDGPdtgNqcuCR4P">808. Soup Servings</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/domino-and-tromino-tiling/&amp;sa=D&amp;source=editors&amp;ust=1627719362130000&amp;usg=AOvVaw1I8HRmlurQlNhdYu7slWZo">790. Domino and Tromino Tiling</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/&amp;sa=D&amp;source=editors&amp;ust=1627719362131000&amp;usg=AOvVaw0C-7mkmcoYMk8BsN4nJN6q">801. Minimum Swaps To Make Sequences Increasing</a></span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/number-of-longest-increasing-subsequence/&amp;sa=D&amp;source=editors&amp;ust=1627719362131000&amp;usg=AOvVaw2hOH3StKGyE7zOPgg1xNWR">673. Number of Longest Increasing Subsequence</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/unique-paths-ii/&amp;sa=D&amp;source=editors&amp;ust=1627719362132000&amp;usg=AOvVaw3sEWZ7zLzDx4zFsvZDF5Dy">63. Unique Paths II</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/out-of-boundary-paths/&amp;sa=D&amp;source=editors&amp;ust=1627719362132000&amp;usg=AOvVaw072xJV3fAJYfyZ8nT7T1L-">576. Out of Boundary Paths</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/&amp;sa=D&amp;source=editors&amp;ust=1627719362132000&amp;usg=AOvVaw1eG8OrByhE0G0iwajjlVoL">1269. Number of Ways to Stay in the Same Place After Some Steps</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Hard</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/count-vowels-permutation/&amp;sa=D&amp;source=editors&amp;ust=1627719362133000&amp;usg=AOvVaw3NOOmNwRxlTvc1JUDrs_Ra">1220. Count Vowels Permutation</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Hard</span></p><h1 class="c14" id="h.xroin455hlhm"><span class="c27 c15">Merging Intervals</span></h1><hr><p class="c8 c25"><span class="c22 c15"></span></p><p class="c5"><span class="c4 c15">Generate problem statement for this pattern</span></p><h3 class="c13" id="h.a5y2y343bbtw"><span class="c19 c15">Statement</span></h3><p class="c28"><span class="c23 c15">Given a set of numbers, find an optimal solution for a problem considering the current number and the best you can get from the left and right sides.</span></p><h3 class="c13" id="h.douaiqvunozw"><span class="c19 c15">Approach</span></h3><p class="c28"><span class="c23 c15">Find all optimal solutions for every interval and return the best possible answer.</span></p><p class="c8"><span class="c12">// from i to j</span></p><p class="c8"><span class="c3">dp[i][j] = dp[i][k] + result[k] + dp[k+</span><span class="c2">1</span><span class="c1">][j]</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c4 c15">Get the best from the left and right sides and add a solution for the current position.</span></p><p class="c8"><span class="c6">for</span><span class="c3">(</span><span class="c6">int</span><span class="c3">&nbsp;l = </span><span class="c2">1</span><span class="c1">; l&lt;n; l++) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">0</span><span class="c1">; i&lt;n-l; i++) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">int</span><span class="c1">&nbsp;j = i+l;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">(</span><span class="c6">int</span><span class="c1">&nbsp;k = i; k&lt;j; k++) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+</span><span class="c2">1</span><span class="c1">][j]);</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">}</span></p><p class="c8"><span class="c1">&nbsp;</span></p><p class="c8"><span class="c6">return</span><span class="c3">&nbsp;dp[</span><span class="c2">0</span><span class="c3">][n</span><span class="c2">-1</span><span class="c1">]</span></p><p class="c7"><span class="c1"></span></p><h3 class="c13" id="h.5mbjyie3sna8"><span class="c19 c15">Similar Problems</span></h3><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/&amp;sa=D&amp;source=editors&amp;ust=1627719362136000&amp;usg=AOvVaw0TrXw-946KmgfIHeDIN8bZ">1130. Minimum Cost Tree From Leaf Values</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;l = </span><span class="c2">1</span><span class="c1">; l &lt; n; ++l) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">0</span><span class="c1">; i &lt; n - l; ++i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">int</span><span class="c1">&nbsp;j = i + l;</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = INT_MAX;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c1">&nbsp;k = i; k &lt; j; ++k) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+</span><span class="c2">1</span><span class="c3">][j] + maxs[i][k] * maxs[k+</span><span class="c2">1</span><span class="c1">][j]);</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/unique-binary-search-trees/&amp;sa=D&amp;source=editors&amp;ust=1627719362137000&amp;usg=AOvVaw16GwtOQaERZB3VRO51IR0C">96. Unique Binary Search Trees</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/minimum-score-triangulation-of-polygon/&amp;sa=D&amp;source=editors&amp;ust=1627719362138000&amp;usg=AOvVaw3WZRJWOZnYIWIUmQ7OPdoz">1039. Minimum Score Triangulation of Polygon</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/remove-boxes/&amp;sa=D&amp;source=editors&amp;ust=1627719362138000&amp;usg=AOvVaw3_pSFJf8bLuHJxevBmffBl">546. Remove Boxes</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/minimum-cost-to-merge-stones/&amp;sa=D&amp;source=editors&amp;ust=1627719362138000&amp;usg=AOvVaw1mOT8B7yVgmbSMFFXxynEw">1000. Minimum Cost to Merge Stones</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/burst-balloons/&amp;sa=D&amp;source=editors&amp;ust=1627719362139000&amp;usg=AOvVaw1g3_DYmuBGqyXOIDuVbj6J">312. Burst Balloons</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Hard</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/guess-number-higher-or-lower-ii/&amp;sa=D&amp;source=editors&amp;ust=1627719362139000&amp;usg=AOvVaw3NUXi-aT5zMY9HhxvgTLiV">375. Guess Number Higher or Lower II</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><h1 class="c14" id="h.5rzngwk6vmzf"><span class="c27 c15">DP on Strings</span></h1><hr><p class="c8 c25"><span class="c22 c15"></span></p><p class="c5"><span class="c4 c15">General problem statement for this pattern can vary but most of the time you are given two strings where lengths of those strings are not big</span></p><h3 class="c13" id="h.od07c3lstaj"><span class="c19 c15">Statement</span></h3><p class="c28"><span class="c23">Given two strings </span><span class="c21">s1</span><span class="c23">&nbsp;and </span><span class="c21">s2</span><span class="c23">, return </span><span class="c21">some result</span><span class="c23 c15">.</span></p><h3 class="c13" id="h.aj9j1ee8f4ky"><span class="c19 c15">Approach</span></h3><p class="c28"><span class="c23 c15">Most of the problems on this pattern requires a solution that can be accepted in O(n^2) complexity.</span></p><p class="c8"><span class="c12">// i - indexing string s1</span></p><p class="c8"><span class="c12">// j - indexing string s2</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">1</span><span class="c1">; i &lt;= n; ++i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;j = </span><span class="c2">1</span><span class="c1">; j &lt;= m; ++j) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">if</span><span class="c3">&nbsp;(s1[i</span><span class="c2">-1</span><span class="c3">] == s2[j</span><span class="c2">-1</span><span class="c1">]) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = </span><span class="c12">/*code*/</span><span class="c1">;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c6">else</span><span class="c1">&nbsp;{</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = </span><span class="c12">/*code*/</span><span class="c1">;</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c28"><span class="c23">If you are given one string </span><span class="c21">s</span><span class="c23 c15">&nbsp;the approach may little vary</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;l = </span><span class="c2">1</span><span class="c1">; l &lt; n; ++l) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">0</span><span class="c1">; i &lt; n-l; ++i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">int</span><span class="c1">&nbsp;j = i + l;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">if</span><span class="c1">&nbsp;(s[i] == s[j]) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = </span><span class="c12">/*code*/</span><span class="c1">;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c6">else</span><span class="c1">&nbsp;{</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = </span><span class="c12">/*code*/</span><span class="c1">;</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/longest-common-subsequence/&amp;sa=D&amp;source=editors&amp;ust=1627719362144000&amp;usg=AOvVaw1kaLlFC6_Q4jlzkg5Ke5Be">1143. Longest Common Subsequence</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">1</span><span class="c1">; i &lt;= n; ++i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;j = </span><span class="c2">1</span><span class="c1">; j &lt;= m; ++j) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">if</span><span class="c3">&nbsp;(text1[i</span><span class="c2">-1</span><span class="c3">] == text2[j</span><span class="c2">-1</span><span class="c1">]) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = dp[i</span><span class="c2">-1</span><span class="c3">][j</span><span class="c2">-1</span><span class="c3">] + </span><span class="c2">1</span><span class="c1">;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c6">else</span><span class="c1">&nbsp;{</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = max(dp[i</span><span class="c2">-1</span><span class="c3">][j], dp[i][j</span><span class="c2">-1</span><span class="c1">]);</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/palindromic-substrings/&amp;sa=D&amp;source=editors&amp;ust=1627719362146000&amp;usg=AOvVaw2f0Kx59Q0-TfJJW6mdLfHc">647. Palindromic Substrings</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;l = </span><span class="c2">1</span><span class="c1">; l &lt; n; ++l) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">0</span><span class="c1">; i &lt; n-l; ++i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">int</span><span class="c1">&nbsp;j = i + l;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">if</span><span class="c3">&nbsp;(s[i] == s[j] &amp;&amp; dp[i+</span><span class="c2">1</span><span class="c3">][j</span><span class="c2">-1</span><span class="c3">] == j-i</span><span class="c2">-1</span><span class="c1">) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = dp[i+</span><span class="c2">1</span><span class="c3">][j</span><span class="c2">-1</span><span class="c3">] + </span><span class="c2">2</span><span class="c1">;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c6">else</span><span class="c1">&nbsp;{</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = </span><span class="c2">0</span><span class="c1">;</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/longest-palindromic-subsequence/&amp;sa=D&amp;source=editors&amp;ust=1627719362148000&amp;usg=AOvVaw138w4sAA-7YUoDwsWEmoH9">516. Longest Palindromic Subsequence</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/shortest-common-supersequence/&amp;sa=D&amp;source=editors&amp;ust=1627719362148000&amp;usg=AOvVaw0klJ-qBRSDsbD8mDmsMyLP">1092. Shortest Common Supersequence</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/edit-distance/&amp;sa=D&amp;source=editors&amp;ust=1627719362148000&amp;usg=AOvVaw3yBICvg3xH076djsV8kx3e">72. Edit Distance</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Hard</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/distinct-subsequences/&amp;sa=D&amp;source=editors&amp;ust=1627719362149000&amp;usg=AOvVaw37qAVPYMy3qQ2Yve78hDeE">115. Distinct Subsequences</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Hard</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/&amp;sa=D&amp;source=editors&amp;ust=1627719362149000&amp;usg=AOvVaw09eEbENQNh3T_BL3kfmhNU">712. Minimum ASCII Delete Sum for Two Strings</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/longest-palindromic-substring/&amp;sa=D&amp;source=editors&amp;ust=1627719362149000&amp;usg=AOvVaw1M0zqktGnErALJejEXv2Tm">5. Longest Palindromic Substring</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><h1 class="c14" id="h.xcpusp3qpira"><span class="c27 c15">Decision Making</span></h1><hr><p class="c8 c25"><span class="c22 c15"></span></p><p class="c5"><span class="c4 c15">The general problem statement for this pattern is forgiven situation decide whether to use or not to use the current state. So, the problem requires you to make a decision at a current state.</span></p><h3 class="c13" id="h.mkndmkhbv0ql"><span class="c19 c15">Statement</span></h3><p class="c28"><span class="c23 c15">Given a set of values find an answer with an option to choose or ignore the current value.</span></p><h3 class="c13" id="h.qxjylk58cfn1"><span class="c19 c15">Approach</span></h3><p class="c28"><span class="c23 c15">If you decide to choose the current value use the previous result where the value was ignored; vice-versa, if you decide to ignore the current value use previous result where value was used.</span></p><p class="c8"><span class="c12">// i - indexing a set of values</span></p><p class="c8"><span class="c12">// j - options to ignore j values</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">1</span><span class="c1">; i &lt; n; ++i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;j = </span><span class="c2">1</span><span class="c1">; j &lt;= k; ++j) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = max({dp[i][j], dp[i</span><span class="c2">-1</span><span class="c3">][j] + arr[i], dp[i</span><span class="c2">-1</span><span class="c3">][j</span><span class="c2">-1</span><span class="c1">]});</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;dp[i][j</span><span class="c2">-1</span><span class="c3">] = max({dp[i][j</span><span class="c2">-1</span><span class="c3">], dp[i</span><span class="c2">-1</span><span class="c3">][j</span><span class="c2">-1</span><span class="c1">] + arr[i], arr[i]});</span></p><p class="c8"><span class="c1">&nbsp; &nbsp;}</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/house-robber/&amp;sa=D&amp;source=editors&amp;ust=1627719362152000&amp;usg=AOvVaw0yLfW9E4IPz4sUYiwZ734A">198. House Robber</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Easy</span></p><p class="c8"><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c6">int</span><span class="c3">&nbsp;i = </span><span class="c2">1</span><span class="c1">; i &lt; n; ++i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;dp[i][</span><span class="c2">1</span><span class="c3">] = max(dp[i</span><span class="c2">-1</span><span class="c3">][</span><span class="c2">0</span><span class="c3">] + nums[i], dp[i</span><span class="c2">-1</span><span class="c3">][</span><span class="c2">1</span><span class="c1">]);</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;dp[i][</span><span class="c2">0</span><span class="c3">] = dp[i</span><span class="c2">-1</span><span class="c3">][</span><span class="c2">1</span><span class="c1">];</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&amp;sa=D&amp;source=editors&amp;ust=1627719362154000&amp;usg=AOvVaw2j_nuUKI0v-k0NUyIobP_Z">121. Best Time to Buy and Sell Stock</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Easy</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/&amp;sa=D&amp;source=editors&amp;ust=1627719362154000&amp;usg=AOvVaw3EZYc0iZhVbjXXz4d7EX_1">714. Best Time to Buy and Sell Stock with Transaction Fee</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/&amp;sa=D&amp;source=editors&amp;ust=1627719362155000&amp;usg=AOvVaw15t3GGgOzxQxytimGw3Tio">309. Best Time to Buy and Sell Stock with Cooldown</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Medium</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/&amp;sa=D&amp;source=editors&amp;ust=1627719362155000&amp;usg=AOvVaw1Z4NKAHRsZwd0CkqHY-C1t">123. Best Time to Buy and Sell Stock III</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Hard</span></p><p class="c5"><span class="c11"><a class="c9" href="https://www.google.com/url?q=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/&amp;sa=D&amp;source=editors&amp;ust=1627719362155000&amp;usg=AOvVaw2pHOG6SairNX569epTgcnp">188. Best Time to Buy and Sell Stock IV</a></span><span class="c4">&nbsp;</span><span class="c21 c15">Hard</span></p><p class="c8 c25"><span class="c15 c22"></span></p><hr style="page-break-before:always;display:none;"><h5 class="c8 c33 c25" id="h.l9o8s3aqdo2j"><span class="c15 c30"></span></h5><h1 class="c8 c33" id="h.vgkeknkvvefj"><span class="c15 c24">From good to great. How to approach most DP problems.</span></h1><p class="c5 c25"><span class="c4 c15"></span></p><p class="c5"><span class="c4 c15">There is some frustration when people publish their perfect fine-grained algorithms without sharing any information abut how they were derived. This is an attempt to change the situation. There is not much more explanation but it&#39;s rather an example of higher level improvements. Converting a solution to the next step shouldn&#39;t be as hard as attempting to come up with perfect algorithm at first attempt.</span></p><p class="c5"><span class="c4 c15">This particular problem and most of others can be approached using the following sequence:</span></p><ol class="c35 lst-kix_h1jtoqhbt4lr-0 start" start="1"><li class="c5 c17 li-bullet-0"><span class="c4 c15">Find recursive relation</span></li><li class="c5 c17 li-bullet-0"><span class="c4 c15">Recursive (top-down)</span></li><li class="c5 c17 li-bullet-0"><span class="c4 c15">Recursive + memo (top-down)</span></li><li class="c5 c17 li-bullet-0"><span class="c4 c15">Iterative + memo (bottom-up)</span></li><li class="c5 c17 li-bullet-0"><span class="c4 c15">Iterative + N variables (bottom-up)</span></li></ol><p class="c5"><span class="c4 c15">Step 1. Figure out recursive relation.</span></p><p class="c5"><span class="c4">A robber has 2 options: a) rob current house </span><span class="c21">i</span><span class="c4 c15">; b) don&#39;t rob current house.</span></p><p class="c5"><span class="c4">If an option &quot;a&quot; is selected it means she can&#39;t rob previous </span><span class="c21">i-1</span><span class="c4">&nbsp;house but can safely proceed to the one before previous </span><span class="c21">i-2</span><span class="c4 c15">&nbsp;and gets all cumulative loot that follows.</span></p><p class="c5"><span class="c4">If an option &quot;b&quot; is selected the robber gets all the possible loot from robbery of </span><span class="c21">i-1</span><span class="c4 c15">&nbsp;and all the following buildings.</span></p><p class="c5"><span class="c4 c15">So it boils down to calculating what is more profitable:</span></p><ul class="c35 lst-kix_z514lf62usd-0 start"><li class="c5 c17 li-bullet-0"><span class="c4 c15">robbery of current house + loot from houses before the previous</span></li><li class="c5 c17 li-bullet-0"><span class="c4 c15">loot from the previous house robbery and any loot captured before that</span></li></ul><p class="c5"><span class="c21 c15">rob(i) = Math.max( rob(i - 2) + currentHouseValue, rob(i - 1) )</span></p><p class="c5"><span class="c4 c15">Step 2. Recursive (top-down)</span></p><p class="c5"><span class="c4 c15">Converting the recurrent relation from Step 1 shound&#39;t be very hard.</span></p><p class="c8"><span class="c6">public</span><span class="c3">&nbsp;</span><span class="c20">int</span><span class="c3">&nbsp;rob(</span><span class="c20">int</span><span class="c1">[] nums) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; </span><span class="c6">return</span><span class="c3">&nbsp;rob(nums, nums.length - </span><span class="c2">1</span><span class="c1">);</span></p><p class="c8"><span class="c1">}</span></p><p class="c8"><span class="c6">private</span><span class="c3">&nbsp;</span><span class="c20">int</span><span class="c3">&nbsp;rob(</span><span class="c20">int</span><span class="c3">[] nums, </span><span class="c20">int</span><span class="c1">&nbsp;i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; </span><span class="c6">if</span><span class="c3">&nbsp;(i &lt; </span><span class="c2">0</span><span class="c1">) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6">return</span><span class="c3">&nbsp;</span><span class="c2">0</span><span class="c1">;</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; </span><span class="c6">return</span><span class="c3">&nbsp;Math.max(rob(nums, i - </span><span class="c2">2</span><span class="c3">) + nums[i], rob(nums, i - </span><span class="c2">1</span><span class="c1">));</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c4">This algorithm will process the same </span><span class="c21">i</span><span class="c4 c15">&nbsp;multiple times and it needs improvement. Time complexity: [to fill]</span></p><p class="c5"><span class="c4 c15">Step 3. Recursive + memo (top-down).</span></p><p class="c8"><span class="c20">int</span><span class="c1">[] memo;</span></p><p class="c8"><span class="c6">public</span><span class="c3">&nbsp;</span><span class="c20">int</span><span class="c3">&nbsp;rob(</span><span class="c20">int</span><span class="c1">[] nums) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; memo = new </span><span class="c20">int</span><span class="c3">[nums.length + </span><span class="c2">1</span><span class="c1">];</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; Arrays.fill(memo, </span><span class="c2">-1</span><span class="c1">);</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; </span><span class="c6">return</span><span class="c3">&nbsp;rob(nums, nums.length - </span><span class="c2">1</span><span class="c1">);</span></p><p class="c8"><span class="c1">}</span></p><p class="c8 c25"><span class="c1"></span></p><p class="c8"><span class="c6">private</span><span class="c3">&nbsp;</span><span class="c20">int</span><span class="c3">&nbsp;rob(</span><span class="c20">int</span><span class="c3">[] nums, </span><span class="c20">int</span><span class="c1">&nbsp;i) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; </span><span class="c6">if</span><span class="c3">&nbsp;(i &lt; </span><span class="c2">0</span><span class="c1">) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6">return</span><span class="c3">&nbsp;</span><span class="c2">0</span><span class="c1">;</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; </span><span class="c6">if</span><span class="c3">&nbsp;(memo[i] &gt;= </span><span class="c2">0</span><span class="c1">) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6">return</span><span class="c1">&nbsp;memo[i];</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; </span><span class="c20">int</span><span class="c3">&nbsp;result = Math.max(rob(nums, i - </span><span class="c2">2</span><span class="c3">) + nums[i], rob(nums, i - </span><span class="c2">1</span><span class="c1">));</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; memo[i] = result;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; </span><span class="c6">return</span><span class="c1">&nbsp;result;</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c4">Much better, this should run in </span><span class="c21">O(n)</span><span class="c4">&nbsp;time. Space complexity is </span><span class="c21">O(n)</span><span class="c4 c15">&nbsp;as well, because of the recursion stack, let&#39;s try to get rid of it.</span></p><p class="c5"><span class="c4 c15">Step 4. Iterative + memo (bottom-up)</span></p><p class="c8"><span class="c6">public</span><span class="c3">&nbsp;</span><span class="c20">int</span><span class="c3">&nbsp;rob(</span><span class="c20">int</span><span class="c1">[] nums) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; </span><span class="c6">if</span><span class="c3">&nbsp;(nums.length == </span><span class="c2">0</span><span class="c3">) </span><span class="c6">return</span><span class="c3">&nbsp;</span><span class="c2">0</span><span class="c1">;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; </span><span class="c20">int</span><span class="c3">[] memo = new </span><span class="c20">int</span><span class="c3">[nums.length + </span><span class="c2">1</span><span class="c1">];</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; memo[</span><span class="c2">0</span><span class="c3">] = </span><span class="c2">0</span><span class="c1">;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; memo[</span><span class="c2">1</span><span class="c3">] = nums[</span><span class="c2">0</span><span class="c1">];</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; </span><span class="c6">for</span><span class="c3">&nbsp;(</span><span class="c20">int</span><span class="c3">&nbsp;i = </span><span class="c2">1</span><span class="c1">; i &lt; nums.length; i++) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c20">int</span><span class="c1">&nbsp;val = nums[i];</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; memo[i+</span><span class="c2">1</span><span class="c3">] = Math.max(memo[i], memo[i</span><span class="c2">-1</span><span class="c1">] + val);</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; </span><span class="c6">return</span><span class="c1">&nbsp;memo[nums.length];</span></p><p class="c8"><span class="c1">}</span></p><p class="c7"><span class="c1"></span></p><p class="c5"><span class="c4 c15">Step 5. Iterative + 2 variables (bottom-up)</span></p><p class="c5"><span class="c4">We can notice that in the previous step we use only </span><span class="c21">memo[i]</span><span class="c4">&nbsp;and </span><span class="c21">memo[i-1]</span><span class="c4 c15">, so going just 2 steps back. We can hold them in 2 variables instead. This optimization is met in Fibonacci sequence creation and some other problems [to paste links].</span></p><p class="c8"><span class="c3">/* the order is: prev2, prev1, num &nbsp;*/</span></p><p class="c8"><span class="c6">public</span><span class="c20">&nbsp;int </span><span class="c1">rob(int[] nums) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c20">if </span><span class="c3">(nums.length == 0)</span><span class="c20">&nbsp;return </span><span class="c1">0;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c20">int </span><span class="c1">prev1 = 0;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c20">int </span><span class="c1">prev2 = 0;</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; for (int num</span><span class="c6">&nbsp;:</span><span class="c1">&nbsp;nums) {</span></p><p class="c8"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20">int </span><span class="c1">tmp = prev1;</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; prev1 = Math.max(prev2 + num, prev1);</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; prev2 = tmp;</span></p><p class="c8"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c8"><span class="c3">&nbsp; &nbsp;</span><span class="c20">return </span><span class="c1">prev1;</span></p><p class="c31"><span class="c1">}</span></p><p class="c5"><span class="c4">Quite commonly, dp tables are built such that </span><span class="c21">dp[m][n]</span><span class="c4 c15">&nbsp;is the ultimate solution. However, there are also a number of DP problems where a variable is updated when building the dp table and the variables contain the final answer(e.g., Problem 647).</span></p><p class="c8 c33"><span class="c4 c15">Last note: keeps practicing! I think I would review those problems for several rounds in the coming weeks, just to keep myself comfortable with DP. When practicing, try to solve with recursive, memoization, tabulation, and even optimize the space when possible.</span></p><p class="c8 c25"><span class="c22 c15"></span></p></body></html>